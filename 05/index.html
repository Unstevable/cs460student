<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Assignment 5 – Three.js Visualization</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>

<!-- Core Three.js library (older version that supports examples/js globals) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>

<!-- OrbitControls (attaches to global THREE.OrbitControls) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>

<!-- AnaglyphEffect -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/effects/AnaglyphEffect.js"></script>

<!-- GLTFLoader -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>

<!-- Tweakpane UI library -->
<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.10/dist/tweakpane.min.js"></script>

<!-- VertexNormalsHelper (for visualizing Blender mesh normals) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/helpers/VertexNormalsHelper.js"></script>

<script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>

</head>
<body>
  <!-- Three.js create and insert the <canvas> element -->

  <script>
    let scene;          
    let camera;         
    let renderer;       
    let controls;       
    let effect;         // anaglyph effect wrapper around the renderer
    let editedMesh; // will hold the mesh loaded from Blender (Hulk.glb)
    let pane;      // main Tweakpane instance
    let sceneui;   // folder for "scene" controls
    let stats;  

    const q_poly_target = new THREE.Quaternion();
    const q_blender_target = new THREE.Quaternion();

    let ambientLight;
    let directionalLight;

    // Settings + helpers for Tweakpane & scene state
    window.SCENE = {
    anaglyph: false,

    // PolyCam mesh + rotation flag
    poly: null,
    rotate_poly: false,
    do_rotate_poly: function () {
        window.SCENE.rotate_poly = !window.SCENE.rotate_poly;
    },

    // reference to the Blender mesh
    blender: null,

    // helper object that draws the normals as little lines
    blender_helper: null,

    // store original material when using MeshNormalMaterial
    blender_old_material: null,

    // toggles between original material and MeshNormalMaterial
    change_material: function () {
        // only do anything if the Blender mesh has been loaded
        if (!window.SCENE.blender) return;

        // first click: store old material and switch to MeshNormalMaterial
        if (!window.SCENE.blender_old_material) {
        window.SCENE.blender_old_material =
            window.SCENE.blender.material.clone();      // keep a copy
        window.SCENE.blender.material =
            new THREE.MeshNormalMaterial();            // show normals as colors
        } else {
        // second click: restore old material and clear the stored copy
        window.SCENE.blender.material =
            window.SCENE.blender_old_material.clone();
        window.SCENE.blender_old_material = null;
        }
    },

    // 180° rotation for Blender mesh (same idea as PolyCam)
    rotate_blender: false,
    do_rotate_blender: function () {
        window.SCENE.rotate_blender = !window.SCENE.rotate_blender;
    }
    };

    window.onload = function () {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // PerspectiveCamera(fov, aspect, near, far)
    camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
    );

    // Slightly above and back, looking at the origin
    camera.position.set(0, 2, 6);
    camera.lookAt(0, 0, 0);



      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Add the renderer's canvas element to the DOM
      document.body.appendChild(renderer.domElement);

      // --- Stats.js widget ---
    stats = new Stats();
    document.body.appendChild(stats.domElement);

      // Allow the user to orbit around the scene with the mouse
      console.log("THREE revision:", THREE.REVISION);
      console.log("OrbitControls type:", typeof THREE.OrbitControls);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;    // smooth movement
      controls.dampingFactor = 0.05;

      // Wrap the renderer in an AnaglyphEffect
      effect = new THREE.AnaglyphEffect(renderer);
      effect.setSize(window.innerWidth, window.innerHeight);

      // ambient light: uniformly lights everything
      ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // color, intensity
      scene.add(ambientLight);

      // directional light: like a distant sun shining in one direction
      directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
      directionalLight.position.set(5, 10, 7); // x, y, z position
      scene.add(directionalLight);

    // Create a new Tweakpane panel
    pane = new Tweakpane.Pane();

    // add a folder called scene to fill with controls
    sceneui = pane.addFolder({ title: 'Scene' });

    const polyui  = pane.addFolder({ title: 'PolyCam Mesh' });
    const blenderui = pane.addFolder({ title: 'Blender Mesh' });

    sceneui.addInput(window.SCENE, 'anaglyph', {
        label: 'Anaglyph'
    });

    sceneui.addInput(directionalLight.position, 'x', {
        min: -100, max: 100, label: 'Light X'
    });

    sceneui.addInput(directionalLight.position, 'y', {
        min: -100, max: 100, label: 'Light Y'
    });

    sceneui.addInput(directionalLight.position, 'z', {
        min: -100, max: 100, label: 'Light Z'
    });

    sceneui.addInput(directionalLight, 'intensity', {
        min: 0, max: 10, label: 'Intensity'
    });

    sceneui.addInput(ambientLight, 'color', {
        label: 'AmbientLight Color'
    });

    polyui.addButton({ title: 'rotate!' }).on('click', () => {
        window.SCENE.do_rotate_poly();
    });

    const loader = new THREE.GLTFLoader();

    // load poly.glb
    loader.load('poly.glb', function (gltf) {

        const poly = gltf.scenes[0].children[0];

        // scale + quaternion
        poly.scale.set(10, 10, 10);
        poly.quaternion.set(0, 0, 0, 1);
        poly.translateX(-5);   

        // tell the helper which mesh is the PolyCam mesh
        window.SCENE.poly = poly;

        // add wireframe checkbox (binds to material.wireframe)
        polyui.addInput(poly.material, 'wireframe', {
            label: 'wireframe'
        });

        scene.add(gltf.scene);
    });

    // Load the edited mesh exported from Blender (Hulk.glb)
    loader.load(
    'Hulk.glb',
    function (gltf) {

        // grab the actual mesh from the scene
        editedMesh = gltf.scene.children[0];

        // reset rotation to identity
        editedMesh.quaternion.set(0, 0, 0, 1);

        // scale ×10 to match PolyCam mesh
        editedMesh.scale.set(10, 10, 10);

        // move it a little to the right so the two models sit side-by-side
        editedMesh.translateX(5);

        // add to the Three.js scene
        scene.add(editedMesh);

        // remember this mesh globally as the "blender" mesh
        window.SCENE.blender = editedMesh;

        // create a VertexNormalsHelper so we can visualize normals
        // 0.1 = length of the normal lines, 0x0000ff = blue color
        const helper = new THREE.VertexNormalsHelper(editedMesh, 0.1, 0x0000ff);

        // start hidden; user can show it via Tweakpane
        helper.visible = false;

        // add helper to scene and remember it
        scene.add(helper);
        window.SCENE.blender_helper = helper;

        // checkbox: show / hide normals helper
        blenderui.addInput(helper, 'visible', { label: 'Show normals!' });

        // button: toggle MeshNormalMaterial on the Blender mesh
        blenderui.addButton({ title: 'Change Material' }).on('click', () => {
        window.SCENE.change_material();
        });

        // button: 180° rotation for Blender mesh
        blenderui.addButton({ title: 'rotate!' }).on('click', () => {
        window.SCENE.do_rotate_blender();
        });

        console.log("Hulk.glb loaded and transformed!", gltf);
    }
    );
      window.addEventListener('resize', onWindowResize, false);

      animate();
    };

    // called whenever the browser window is resized
    function onWindowResize() {
      // update camera aspect ratio and projection
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      // resize renderer & anaglyph effect
      renderer.setSize(window.innerWidth, window.innerHeight);
      effect.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        controls.update();

        // rotate PolyCam mesh when requested
        if (window.SCENE.poly) {
            if (window.SCENE.rotate_poly) {
                // 180 degrees around Y axis
                q_poly_target.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
            } else {
                // back to original orientation
                q_poly_target.identity();
            }

            // smooth interpolation toward target rotation
            window.SCENE.poly.quaternion.slerp(q_poly_target, 0.01);
        }

        // rotate Blender mesh when requested 
        if (window.SCENE.blender) {
            if (window.SCENE.rotate_blender) {
                // target = 180 degrees around Y axis
                q_blender_target.setFromAxisAngle(
                    new THREE.Vector3(0, 1, 0),
                    Math.PI
                );
            } else {
                // target = original orientation
                q_blender_target.identity();
            }

            // smooth interpolation toward target rotation
            window.SCENE.blender.quaternion.slerp(q_blender_target, 0.01);

            // If we have a normals helper, keep it in sync
            if (window.SCENE.blender_helper) {
                window.SCENE.blender_helper.update();
            }
        }

        if (window.SCENE.anaglyph) {
            effect.render(scene, camera);
        } else {
            renderer.render(scene, camera);
        }

        stats.update();

    }

  </script>
</body>
</html>
